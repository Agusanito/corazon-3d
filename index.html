<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Corazón 3D interactivo (standalone controls)</title>
  <style>
    :root{
      --bg:#060a12;
      --panel: rgba(255,255,255,.06);
      --text:#eef2ff;
      --muted: rgba(238,242,255,.70);
      --ring: 0 0 0 5px rgba(99,102,241,.22);
      --radius: 18px;
      --shadow: 0 18px 55px rgba(0,0,0,.45);
    }
    *{box-sizing:border-box}
    html, body{margin:0; height:100%; min-height:100vh; background:var(--bg); color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}
    #app{height:100vh; height:100dvh; display:grid; grid-template-columns: 1fr 360px;}
    #view{position:relative; overflow:hidden; min-height:320px;
      background: radial-gradient(900px 520px at 30% 20%, rgba(99,102,241,.18), transparent 55%),
                  radial-gradient(800px 480px at 75% 70%, rgba(56,189,248,.12), transparent 55%),
                  #060a12;}
    canvas{display:block; width:100%; height:100%;}
    .hud{position:absolute; left:14px; top:14px; z-index:5;
      padding:10px 12px; border-radius:14px; background: rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.12); backdrop-filter: blur(10px);
      font-size:12px; color: rgba(238,242,255,.88); max-width:min(520px, calc(100% - 28px));}
    .error{position:absolute; left:14px; right:14px; top:70px; z-index:6;
      padding:12px; border-radius:14px; background: rgba(255,0,80,.10);
      border:1px solid rgba(255,0,80,.25); color: rgba(255,255,255,.92);
      font-size:12px; line-height:1.35; backdrop-filter: blur(10px);}
    .sidebar{border-left:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      padding:16px; display:flex; flex-direction:column; gap:12px; overflow:auto;
      -webkit-overflow-scrolling: touch;}
    .card{background: var(--panel); border:1px solid rgba(255,255,255,.10); border-radius:var(--radius);
      box-shadow: var(--shadow); padding:14px;}
    h1{font-size:18px; margin:0 0 8px; letter-spacing:-.2px}
    .note{color:var(--muted); font-size:13px; line-height:1.35; margin:0}
    .kv{display:grid; grid-template-columns:110px 1fr; gap:8px; align-items:start}
    .kv div{font-size:13px}
    .muted{color:var(--muted)}
    .divider{height:1px; background: rgba(255,255,255,.10); margin:10px 0}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    label{font-size:12px; color:var(--muted)}
    input[type="range"]{width:100%}
    .btn{border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06); color:var(--text);
      padding:10px 12px; border-radius:14px; font-size:13px; cursor:pointer; user-select:none;}
    .btn:hover{background: rgba(255,255,255,.10)}
    .btn:focus{outline:none; box-shadow: var(--ring)}
    .chips{display:flex; gap:8px; flex-wrap:wrap}
    .chip{display:inline-flex; align-items:center; padding:8px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05);
      font-size:12px; color: rgba(238,242,255,.88); cursor:pointer; user-select:none; max-width:100%;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    .chip[aria-pressed="true"]{background: rgba(99,102,241,.20); border-color: rgba(99,102,241,.35)}
    .small{font-size:12px; color:var(--muted); line-height:1.35}
    @media (max-width: 980px){
      #app{grid-template-columns:1fr; grid-template-rows:62dvh auto;}
      .sidebar{border-left:none; border-top:1px solid rgba(255,255,255,.10)}
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="view">
      <div class="hud">Arrastra para rotar · Pellizca para zoom · Toca una pieza para ver detalle.</div>
      <div class="error" id="err">
        Cargando… Si esto no desaparece, el JavaScript no se está ejecutando (o no pudo cargar Three.js).
        Abre el link en Safari y verifica conexión.
      </div>
    </div>

    <aside class="sidebar">
      <div class="card">
        <h1>Corazón 3D interactivo</h1>
        <p class="note">
          Modelo <strong>esquemático</strong> (formas simples) para explorar cavidades y grandes vasos.
          No incluye válvulas/coronarias ni proporciones clínicas. <strong>No es apto para diagnóstico</strong>.
        </p>
      </div>

      <div class="card">
        <div class="kv">
          <div class="muted">Selección</div><div id="selName">Ninguna</div>
          <div class="muted">Descripción</div><div id="selDesc" class="muted">Toca una pieza.</div>
        </div>
        <div class="divider"></div>
        <div class="row">
          <button class="btn" id="resetBtn">Recentrar vista</button>
          <button class="btn" id="explodeBtn" aria-pressed="false">Exploded view</button>
        </div>
      </div>

      <div class="card">
        <label for="cut">Corte (plano) — ver interior</label>
        <input id="cut" type="range" min="-1.2" max="1.2" step="0.01" value="0.95" />
        <div class="small">Slider = “rebanar” el modelo (clipping plane en X).</div>
        <div class="divider"></div>
        <div class="row">
          <button class="btn" id="transBtn" aria-pressed="false">Transparencia</button>
          <button class="btn" id="labelsBtn" aria-pressed="true">Etiquetas</button>
        </div>
        <div class="divider"></div>
        <div class="muted" style="font-size:12px; margin-bottom:8px;">Mostrar/ocultar piezas</div>
        <div class="chips" id="chips"></div>
      </div>

      <div class="card">
        <div class="small">
          Esta versión elimina OrbitControls (fue la causa del error). Solo depende de Three.js desde CDN.
        </div>
      </div>
    </aside>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    (function(){
      const errBox = document.getElementById("err");
      const container = document.getElementById("view");

      function setErr(msg){
        errBox.textContent = msg;
        errBox.style.display = "block";
        console.error(msg);
      }

      if (!window.THREE || !THREE.WebGLRenderer){
        setErr("No se pudo cargar Three.js desde el CDN. Verifica conexión a Internet o bloqueos de contenido.");
        return;
      }

      function webglOK(){
        try{
          const c = document.createElement("canvas");
          return !!(window.WebGLRenderingContext && (c.getContext("webgl") || c.getContext("experimental-webgl")));
        }catch(e){ return false; }
      }
      if (!webglOK()){
        setErr("WebGL no está disponible, así que no se puede renderizar el modelo 3D.");
        return;
      }

      function waitForSize(cb){
        let tries = 0;
        (function tick(){
          const w = container.clientWidth, h = container.clientHeight;
          if (w > 50 && h > 50) return cb(w,h);
          tries++;
          if (tries > 120) return cb(Math.max(w,800), Math.max(h,500));
          requestAnimationFrame(tick);
        })();
      }

      const labelLayer = document.createElement("div");
      labelLayer.style.position = "absolute";
      labelLayer.style.inset = "0";
      labelLayer.style.pointerEvents = "none";
      container.appendChild(labelLayer);

      function makeLabel(text){
        const el = document.createElement("div");
        el.textContent = text;
        el.style.position = "absolute";
        el.style.padding = "6px 9px";
        el.style.borderRadius = "999px";
        el.style.fontSize = "12px";
        el.style.color = "rgba(238,242,255,.92)";
        el.style.background = "rgba(0,0,0,.38)";
        el.style.border = "1px solid rgba(255,255,255,.14)";
        el.style.backdropFilter = "blur(10px)";
        el.style.transform = "translate(-50%, -120%)";
        el.style.whiteSpace = "nowrap";
        el.style.maxWidth = "220px";
        el.style.overflow = "hidden";
        el.style.textOverflow = "ellipsis";
        labelLayer.appendChild(el);
        return el;
      }

      waitForSize(function(w,h){
        const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:"high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(w,h,false);
        renderer.localClippingEnabled = true;
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x060a12, 8, 22);

        const camera = new THREE.PerspectiveCamera(45, w/h, 0.1, 200);

        // Minimal orbit controls
        const controls = (function(){
          const state = {
            target: new THREE.Vector3(0,1.4,0),
            theta: Math.PI * 0.25,
            phi:   Math.PI * 0.30,
            radius: 9.0,
            isDown: false,
            lastX: 0,
            lastY: 0,
            damping: 0.12,
            vTheta: 0,
            vPhi: 0,
            vRadius: 0
          };
          function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
          function apply(){
            state.theta += state.vTheta; state.vTheta *= (1 - state.damping);
            state.phi   += state.vPhi;   state.vPhi   *= (1 - state.damping);
            state.radius += state.vRadius; state.vRadius *= (1 - state.damping);

            state.phi = clamp(state.phi, 0.05, Math.PI - 0.05);
            state.radius = clamp(state.radius, 2.8, 35);

            const sinPhi = Math.sin(state.phi);
            const x = state.radius * sinPhi * Math.cos(state.theta);
            const y = state.radius * Math.cos(state.phi);
            const z = state.radius * sinPhi * Math.sin(state.theta);

            camera.position.set(state.target.x + x, state.target.y + y, state.target.z + z);
            camera.lookAt(state.target);
          }

          renderer.domElement.addEventListener("pointerdown", (e)=>{
            state.isDown = true;
            state.lastX = e.clientX;
            state.lastY = e.clientY;
            try{ renderer.domElement.setPointerCapture(e.pointerId); }catch(_){}
          });

          renderer.domElement.addEventListener("pointermove", (e)=>{
            if (!state.isDown) return;
            const dx = e.clientX - state.lastX;
            const dy = e.clientY - state.lastY;
            state.lastX = e.clientX;
            state.lastY = e.clientY;
            state.vTheta += -dx * 0.006;
            state.vPhi   += -dy * 0.006;
          });

          renderer.domElement.addEventListener("pointerup", (e)=>{
            state.isDown = false;
            try{ renderer.domElement.releasePointerCapture(e.pointerId); }catch(_){}
          });

          renderer.domElement.addEventListener("wheel", (e)=>{
            e.preventDefault();
            state.vRadius += e.deltaY * 0.01;
          }, { passive:false });

          let pinch = { active:false, dist:0 };
          function dist(t1,t2){
            const dx = t1.clientX - t2.clientX;
            const dy = t1.clientY - t2.clientY;
            return Math.sqrt(dx*dx + dy*dy);
          }
          renderer.domElement.addEventListener("touchstart", (e)=>{
            if (e.touches.length === 2){
              pinch.active = true;
              pinch.dist = dist(e.touches[0], e.touches[1]);
            }
          }, { passive:true });

          renderer.domElement.addEventListener("touchmove", (e)=>{
            if (pinch.active && e.touches.length === 2){
              const d = dist(e.touches[0], e.touches[1]);
              const delta = pinch.dist - d;
              pinch.dist = d;
              state.vRadius += delta * 0.02;
            }
          }, { passive:true });

          renderer.domElement.addEventListener("touchend", (e)=>{
            if (e.touches.length < 2) pinch.active = false;
          }, { passive:true });

          return {
            state,
            update: apply,
            frameTo: function(obj){
              const box = new THREE.Box3().setFromObject(obj);
              if (box.isEmpty()) return;
              const size = new THREE.Vector3(); box.getSize(size);
              const center = new THREE.Vector3(); box.getCenter(center);
              const maxDim = Math.max(size.x, size.y, size.z);
              const fov = camera.fov * Math.PI / 180;
              let dist = Math.abs(maxDim / (2 * Math.tan(fov/2)));
              dist *= 1.4;
              state.target.copy(center);
              state.radius = Math.max(4.5, dist);
              state.theta = Math.PI * 0.25;
              state.phi   = Math.PI * 0.33;
              state.vTheta = state.vPhi = state.vRadius = 0;
              camera.near = Math.max(0.05, maxDim/100);
              camera.far = Math.max(50, maxDim*20);
              camera.updateProjectionMatrix();
              apply();
            }
          };
        })();

        // Lights
        scene.add(new THREE.HemisphereLight(0xbfd7ff, 0x06111f, 0.75));
        const key = new THREE.DirectionalLight(0xffffff, 1.2); key.position.set(6,8,6); scene.add(key);
        const rim = new THREE.DirectionalLight(0x9aa4ff, 0.6); rim.position.set(-6,3,-7); scene.add(rim);

        // Floor
        const floor = new THREE.Mesh(
          new THREE.CircleGeometry(7.5, 96),
          new THREE.MeshStandardMaterial({ color: 0x0a1020, roughness: 1.0, metalness: 0.0, transparent:true, opacity:0.55 })
        );
        floor.rotation.x = -Math.PI/2; floor.position.y = -0.15; scene.add(floor);

        // Clipping
        const clipPlane = new THREE.Plane(new THREE.Vector3(-1,0,0), 0.95);
        function mat(color, opacity){
          return new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.55,
            metalness: 0.05,
            transparent: true,
            opacity: (opacity == null ? 0.98 : opacity),
            side: THREE.DoubleSide,
            clippingPlanes: [clipPlane]
          });
        }

        const group = new THREE.Group();
        scene.add(group);

        const parts = [];
        const labels = new Map();

        function addPart(name, desc, mesh, labelOffset){
          mesh.userData = { name:name, desc:desc, labelOffset: labelOffset || new THREE.Vector3(0,0.4,0) };
          parts.push(mesh);
          group.add(mesh);
          labels.set(mesh.uuid, makeLabel(name));
          return mesh;
        }

        // Heart parts
        const lv = addPart("Ventrículo izquierdo", "Cámara que impulsa sangre oxigenada hacia la aorta (simplificado).",
          new THREE.Mesh(new THREE.SphereGeometry(1.25, 56, 48), mat(0xff5b6e, 0.98)), new THREE.Vector3(0.2,0.9,0));
        lv.scale.set(1.0, 1.25, 0.95); lv.position.set(0.5, 1.05, 0.0);

        const rv = addPart("Ventrículo derecho", "Cámara que impulsa sangre hacia la arteria pulmonar (simplificado).",
          new THREE.Mesh(new THREE.SphereGeometry(1.05, 56, 48), mat(0xff8896, 0.98)), new THREE.Vector3(-0.25,0.85,0.2));
        rv.scale.set(1.05, 1.15, 0.95); rv.position.set(-0.55, 0.95, 0.35);

        const la = addPart("Atrio izquierdo", "Recibe sangre oxigenada desde venas pulmonares (no detalladas).",
          new THREE.Mesh(new THREE.SphereGeometry(0.75, 48, 40), mat(0xff3f57, 0.92)), new THREE.Vector3(0.45,0.6,-0.1));
        la.scale.set(1.0, 0.9, 1.1); la.position.set(0.95, 2.35, -0.1);

        const ra = addPart("Atrio derecho", "Recibe sangre venosa desde venas cavas (simplificado).",
          new THREE.Mesh(new THREE.SphereGeometry(0.78, 48, 40), mat(0xff7080, 0.92)), new THREE.Vector3(-0.55,0.6,-0.1));
        ra.scale.set(1.05, 0.9, 1.1); ra.position.set(-1.05, 2.15, 0.05);

        const aorta = addPart("Aorta (esquema)", "Conducto principal de salida del ventrículo izquierdo (simplificado).",
          new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.26, 2.8, 32), mat(0xff2b45, 0.96)), new THREE.Vector3(0.55,0.55,0.2));
        aorta.position.set(1.15, 3.0, 0.1); aorta.rotation.z = -0.35; aorta.rotation.x = 0.15;

        const pa = addPart("Arteria pulmonar (esquema)", "Salida del ventrículo derecho hacia los pulmones (no incluidos).",
          new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.22, 2.3, 32), mat(0xff6b7a, 0.96)), new THREE.Vector3(-0.55,0.6,0.2));
        pa.position.set(-1.35, 2.95, 0.45); pa.rotation.z = 0.55; pa.rotation.x = -0.1;

        const svc = addPart("Vena cava superior (esquema)", "Entrada superior hacia el atrio derecho (simplificado).",
          new THREE.Mesh(new THREE.CylinderGeometry(0.20, 0.22, 2.0, 28), mat(0x6aa8ff, 0.96)), new THREE.Vector3(-0.55,0.5,-0.25));
        svc.position.set(-1.05, 3.55, -0.2);

        const ivc = addPart("Vena cava inferior (esquema)", "Entrada inferior hacia el atrio derecho (simplificado).",
          new THREE.Mesh(new THREE.CylinderGeometry(0.20, 0.22, 2.1, 28), mat(0x6aa8ff, 0.96)), new THREE.Vector3(-0.7,-0.1,-0.1));
        ivc.position.set(-0.95, 1.1, -0.25); ivc.rotation.x = 0.12;

        // Conduits
        const conduitMat = mat(0xffffff, 0.22);
        function conduit(p1,p2,r){
          r = r || 0.10;
          const dir = new THREE.Vector3().subVectors(p2,p1);
          const len = dir.length();
          const geom = new THREE.CylinderGeometry(r,r,len,22);
          const m = new THREE.Mesh(geom, conduitMat);
          const mid = new THREE.Vector3().addVectors(p1,p2).multiplyScalar(0.5);
          m.position.copy(mid);
          m.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.normalize());
          m.material.clippingPlanes = [clipPlane];
          return m;
        }
        const conduits = new THREE.Group();
        conduits.add(conduit(ra.position, rv.position, 0.11));
        conduits.add(conduit(rv.position, pa.position, 0.10));
        conduits.add(conduit(la.position, lv.position, 0.11));
        conduits.add(conduit(lv.position, aorta.position, 0.10));
        group.add(conduits);

        group.position.set(0, 0.15, 0);

        // Frame and mark ready
        controls.frameTo(group);
        errBox.style.display = "none";

        // UI chips
        const chipsEl = document.getElementById("chips");
        parts.forEach((m)=>{
          const b = document.createElement("button");
          b.type = "button";
          b.className = "chip";
          b.textContent = m.userData.name;
          b.setAttribute("aria-pressed","true");
          b.addEventListener("click", ()=>{
            const on = b.getAttribute("aria-pressed") === "true";
            b.setAttribute("aria-pressed", String(!on));
            m.visible = !on;
            const el = labels.get(m.uuid);
            if (el) el.style.display = m.visible ? "" : "none";
          });
          chipsEl.appendChild(b);
        });

        // Selection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selected = null;
        const selName = document.getElementById("selName");
        const selDesc = document.getElementById("selDesc");

        function setSelected(mesh){
          if (selected && selected.material && selected.material.emissive){
            selected.material.emissive.setHex(0x000000);
          }
          selected = mesh;
          if (!mesh){
            selName.textContent = "Ninguna";
            selDesc.textContent = "Toca una pieza.";
            return;
          }
          selName.textContent = mesh.userData.name;
          selDesc.textContent = mesh.userData.desc;
          if (!mesh.material.emissive) mesh.material.emissive = new THREE.Color(0x000000);
          mesh.material.emissive.setRGB(0.18,0.18,0.18);
        }

        renderer.domElement.addEventListener("pointerdown", (e)=>{
          const rect = renderer.domElement.getBoundingClientRect();
          mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
          raycaster.setFromCamera(mouse, camera);
          const hits = raycaster.intersectObjects(parts.filter(p=>p.visible), false);
          setSelected(hits.length ? hits[0].object : null);
        }, { passive:true });

        // Cut slider
        document.getElementById("cut").addEventListener("input", (e)=>{
          clipPlane.constant = parseFloat(e.target.value);
        });

        // Transparency
        const transBtn = document.getElementById("transBtn");
        let transparentMode = false;
        transBtn.addEventListener("click", ()=>{
          transparentMode = !transparentMode;
          transBtn.setAttribute("aria-pressed", String(transparentMode));
          parts.forEach(m=>{
            const base = (m.userData.name.indexOf("Vena") >= 0) ? 0.92 : 0.98;
            m.material.opacity = transparentMode ? Math.min(0.35, base) : base;
            m.material.needsUpdate = true;
          });
          conduitMat.opacity = transparentMode ? 0.10 : 0.22;
          conduitMat.needsUpdate = true;
        });

        // Labels toggle
        const labelsBtn = document.getElementById("labelsBtn");
        let labelsOn = true;
        labelsBtn.addEventListener("click", ()=>{
          labelsOn = !labelsOn;
          labelsBtn.setAttribute("aria-pressed", String(labelsOn));
          labelLayer.style.display = labelsOn ? "" : "none";
        });

        // Reset
        document.getElementById("resetBtn").addEventListener("click", ()=>controls.frameTo(group));

        // Explode
        const explodeBtn = document.getElementById("explodeBtn");
        let exploded = false;
        const basePos = parts.map(m=>m.position.clone());
        explodeBtn.addEventListener("click", ()=>{
          exploded = !exploded;
          explodeBtn.setAttribute("aria-pressed", String(exploded));
          for (let i=0;i<parts.length;i++){
            const m = parts[i];
            if (!exploded){
              m.position.copy(basePos[i]);
            } else {
              const v = basePos[i].clone().sub(new THREE.Vector3(0,1.6,0));
              if (v.length() < 1e-6) v.set(1,0,0);
              v.normalize().multiplyScalar(0.65);
              m.position.copy(basePos[i].clone().add(v));
            }
          }
          controls.frameTo(group);
        });

        // Labels projection
        const tmp = new THREE.Vector3();
        function updateLabels(){
          if (!labelsOn) return;
          const ww = container.clientWidth, hh = container.clientHeight;
          parts.forEach(m=>{
            const el = labels.get(m.uuid);
            if (!el) return;
            if (!m.visible){ el.style.display="none"; return; }
            el.style.display="";
            tmp.copy(m.position).add(m.userData.labelOffset);
            tmp.applyMatrix4(group.matrixWorld);
            tmp.project(camera);
            el.style.left = ((tmp.x*0.5+0.5)*ww) + "px";
            el.style.top  = ((-tmp.y*0.5+0.5)*hh) + "px";
            el.style.opacity = (tmp.z < 1) ? "1" : "0";
          });
        }

        // Resize
        const ro = new ResizeObserver(()=>{
          const ww = container.clientWidth, hh = container.clientHeight;
          if (ww < 10 || hh < 10) return;
          renderer.setSize(ww, hh, false);
          camera.aspect = ww / hh;
          camera.updateProjectionMatrix();
        });
        ro.observe(container);

        // Loop
        (function animate(){
          requestAnimationFrame(animate);
          controls.update();
          updateLabels();
          renderer.render(scene, camera);
        })();
      });
    })();
  </script>
</body>
</html>
